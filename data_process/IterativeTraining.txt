일단 모델은 인코더 언어 모델. 실험에서는 Roberta-Large를 사용하였다고 함.
나는 ModernBERT를 사용하려고 함.

그럼 이 Decider의 훈련 과정이 어떻게 되는가. 어떤 데이터를 준비해야 하는가.

데이터는 우선 500개 정도 마련할 생각.

그러면 데이터 모양을 어떻게 만들어야 하냐...

상태 전환 개념 정의
1. 현재 상태는 주어짐. 이를 기반으로 다음 상태의 점수를 구함
2. 해당 점수는 매 토큰 생성마다 계산함
3. 점수는 어떻게 구할 것인가.
3.1 점수는 토큰 로짓이다? scalar가 아니야? 수식만 보면 scalar여야 하는데
3.2 각 상태는 정해진 시작 문자를 가진다... 그래서 각 상태를 토큰 로짓으로 표현할 수 있다.
3.3 아니. 수식을 보면 토큰 로짓을 가지고 또 확률을 구하는 방식. 그 중에서도 다음 상태가 될 수 있는 토큰 로짓만 가지고 확률을 구한다?
3.4 토큰의 확률이 다음 상태를 나타낸다. 
3.5 결국 decider에서 나오는 정보도 softmax를 거치는 확률값으로 귀결
3.6 Score = 확률 + 확률, Score도 확률

디코딩 과정에서 수식 (4)에 따라 상태 전이 제어가 일어난다.

각 상태 정의
S_s: 시작 상태. 
[이전 상태 0에서 시작 토큰 '{']
S_key^g: 키 생성 상태. 
[이전 상태 S_s에서 시작 토큰 '"', 이전 상태 S_value^f에서 시작 토큰 ',']
S_value^g: 값 생성 상태. 
[이전 상태 S_key^g에서 시작 토큰 '"', 이전 상태 S_value^g에서 시작 토큰 ',']
S_value^f: 값 생성 종료 상태. 
[이전 상태 S_value^g에서 상징 토큰은 ']', 이전 상태 S_key^g에서 시작 토큰 ']']
S_e: 생성 종료 상태. 
[이전 상태 S_s에서 시작 토큰 '}', 이전 상태 S_value^f에서 시작 토큰 '}']

모든 디코딩 과정에서 상태 제어가 개입
즉, 모든 토큰 생성에서 개입하면서 
데이터셋 구축 방법

데이터 구성 규칙
현재 상태가 S_s, S_value^f이면 prompt_b로
현재 상태가 S_key^g, S_value^g일 때 prompt_a
S_key^g일 때는 현재 찾은 entity 갱신 없이, S_value^g가 되는 순간부터 찾은 entity 갱신
S_value^f가 되면 찾은 entity 초기화